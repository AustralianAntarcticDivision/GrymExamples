<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Grym</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Grym</h1>



<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>Motivational text. Reference <span class="citation">Constable and de la Mare (1996)</span>.</p>
</div>
<div id="history" class="section level2">
<h2>History</h2>
<p>History of KYM/GYM.</p>
</div>
<div id="projection" class="section level2">
<h2>Projection</h2>
<p>The core functionality of the GYM is to project stock abundance, biomass and yield in each age class forward in time over a single year.</p>
<p>The GYM projects stock abundance, biomass and yield forward over time by integrating a system of differential equations with an adpative Runge-Kutta scheme. The GYM assumes the number <span class="math inline">\(N_{a,y}\)</span>, biomass <span class="math inline">\(B_{a,y}\)</span> and yield <span class="math inline">\(Y_{a,y}\)</span> of individuals of age <span class="math inline">\(a\)</span> in year <span class="math inline">\(y\)</span> satisfy the sytem of differential equations (<span class="citation">Constable and de la Mare (1996)</span>) <span class="math display">\[
\begin{align}
\frac{dN_{a,y}}{dt} &amp;= - \Big [ M_{y} m(a,t,y)  + F_{y} f(a,t,y) \Big ] N_{a,y}\\
\frac{dB_{a,y}}{dt} &amp;= w(a+t)\frac{dN_{a,y}}{dt} + N_{a,y}(t) \frac{dw(a+t)}{dt}\\
\frac{dY_{a,y}}{dt} &amp;= F_{y} f(a,t,y) B_{a,y}
\end{align}
\]</span> where <span class="math inline">\(w(a+t)\)</span> represents the weight at total age <span class="math inline">\(a+t\)</span>, and the total natural mortality <span class="math inline">\(M_{y} m(a,t,y)\)</span> has been decomposed into an annually varying component <span class="math inline">\(M_{y}\)</span> and a component <span class="math inline">\(m(a,t,y)\)</span> that varies within years, and similarly the total fishing mortality <span class="math inline">\(F_{y} f(a,t,y)\)</span> has been decomposed into an annual component <span class="math inline">\(F_{Y}\)</span> and a component <span class="math inline">\(f(a,t,y)\)</span> that varies within years. To ensure identifiability of the parameters, an appropriate normalization must be chosen for the within year components of mortality. The total yield in each year is the sum of the contributions from each age class <span class="math display">\[
Y_{y} = \sum_{a} Y_{a,y}(1).  
\]</span></p>
<p>The GYM solves this system of differential equations for each year by assuming the time varying functions <span class="math inline">\(m(a,t,y)\)</span>, <span class="math inline">\(f(a,t,y)\)</span> and <span class="math inline">\(w(a+t)\)</span> are piecewise linear, and integrating the system with an adaptive Runge-Kutta scheme.</p>
<p>Grym takes a more direct approach. The system of governing equations has solution <span class="math display">\[
\begin{align}
N_{a,y}(t) &amp;= N_{a,y}(0)\exp \left [ - M_{y} \int_{y}^{y+t} m(a,\tau,y) d \tau  -  F_{y} \int_{y}^{y+t}f(a,\tau,y) d \tau\right ]\\
B_{a,y}(t) &amp;= w(a+t) N_{a,y}(t)\\
Y_{a,y}(t) &amp;= \int_{y}^{y+t}F_{y}f(a,\tau,y)B_{a,y}(\tau) d \tau.
\end{align}
\]</span> Grym uses this solution directly, evaluating the required integrals by numerical quadrature. As <span class="math inline">\(m(a,t,y)\)</span> and <span class="math inline">\(f(a,t,y)\)</span> are assumed piecewise linear, the composite trapezoidal rule will yield exact solutions for <span class="math inline">\(N_{a,y}\)</span> and <span class="math inline">\(B_{a,y}\)</span>.</p>
</div>
<div id="data-structures-and-notation" class="section level2">
<h2>Data Structures and Notation</h2>
<p>Within a projection over a single year, the main model parameters and start variables are stored as matrices with an entry for each time step and modelled age class. The naming of these quantities is consistent throughout the Grym source code and examples, and is described in detail here.</p>
<p>An <em>annual matrix</em> is a matrix with one row for the initial time and each subsequent time step through the year, and one column for each modelled age class. For example, if a year is assumed to consist of 365 days and a daily time step is adopted, each annual matrix will have 366 rows with the first row representing to midnight on the last day of the previous year, and the last row representing midnight on the final day of the current year. Only modelled ages classes are represented, so the first column does not necessarily correspond to 0 to 1 year olds, and the final column may be a plus class representing an aggregation of the oldest age classes in the population. So if 5 age classes are modelled, recruits enter the modelled population at age 3 and the final age class is a “plus” class, the columns would represent ages the age ranges 3-4, 4-5, 5-6, 6-7 and 7+.</p>
<p>The GYM assumes rigid deterministic relationships between growth, maturation and fishing selectivity. The length of an individual is a function of age, weight is a function of length, and maturity and selectivity are functions of length or age. In Grym, within each year these quantities are represented as annual matrices as follows:</p>
<ul>
<li><code>as</code> is an annual matrix of ages, so that <code>as[i,j]</code> is the age of an individual in age class <code>j</code> at the beginning of time step <code>i</code>;</li>
<li><code>ls</code> is an annual matrix of lengths, so that <code>ls[i,j]</code> is the length of an individual in age class <code>j</code> at the beginning of time step <code>i</code>;</li>
<li><code>ws</code> is an annual matrix of weights, so that <code>ws[i,j]</code> is the weight of an individual in age class <code>j</code> at the beginning of time step <code>i</code>;</li>
<li><code>gs</code> is an annual matrix of maturity, so that <code>gs[i,j]</code> is the fraction of mature individuals in age <code>j</code> at the beginning of time step <code>i</code>;</li>
<li><code>ss</code> is an annual matrix of fishing selectivity, so that <code>ss[i,j]</code> is the fraction of individuals susceptable to fishing in age <code>j</code> at the beginning of time step <code>i</code>.</li>
</ul>
<p>The precise form of the functional relationships between these quantities is esentially arbitrary and may vary from year to year and replicate to replicate, provided that the first and last rows remain consistent across years. Only the weights <code>ws</code>, maturity <code>gs</code> and fishing selectivity <code>ss</code> matrices are required to compute an annual projection, the lengths <code>ls</code> and ages <code>as</code> are a useful convenience.</p>
<p>The natural and fishing mortalities are decomposed into the intra-annual components <span class="math inline">\(m(a,t,y)\)</span> and <span class="math inline">\(f(a,t,y)\)</span>, and annual scalings <span class="math inline">\(M_{y}\)</span> and <span class="math inline">\(F_{y}\)</span> for that year. For a projection over a single year, <span class="math inline">\(M_{y}\)</span> and <span class="math inline">\(F_{y}\)</span> are just constants, and the intra-annaul components are stored as annual matrices:</p>
<ul>
<li><code>ms</code> is an annual matrix of the intra-annual component of natural mortality <span class="math inline">\(m(a,t,y)\)</span>;</li>
<li><code>fs</code> is an annual matrix of the intra-annual component of fishing mortality <span class="math inline">\(f(a,t,y)\)</span>.</li>
</ul>
<p>These matrices are called the <em>unscaled</em> natural and fishing mortalities; when scaled by <span class="math inline">\(M_{y}\)</span> and <span class="math inline">\(F_{y}\)</span> they are the <em>scaled</em> natural and fishing mortalities:</p>
<ul>
<li><code>Mms</code> is an annual matrix of the total natural mortality <span class="math inline">\(M_{y} m(a,t,y)\)</span>;</li>
<li><code>Ffs</code> is an annual matrix of the total fishing mortality <span class="math inline">\(F_{y} f(a,t,y)\)</span>.</li>
</ul>
<p>The form of <code>ms</code> and <code>fs</code> is essentially arbitrary, but in the absence of better information the unscaled natural mortality is typically assumed constant over a year, while the unscaled fishing mortality is typically chosen as the product of the fishing selectivity <code>ss</code> and some measure of fishing effort at each time step. To ensure the annual scalings <span class="math inline">\(M_{y}\)</span> and <span class="math inline">\(F_{y}\)</span> are identifiable, some appropriate normalization must be imposed upon <code>ms</code> and <code>fs</code>; and this is left to the discretion of the user.</p>
<p>Computing a projection forward over a year also requires various integrals of the natural and fishing mortalities. These quantities are expensive to compute but often do not vary from year to year,so for efficiency Grym requires the user to provide these rather than recompute them for each year. The <em>unscaled integrated</em> mortalities <span class="math display">\[
\int_{y}^{y+t} m(a,\tau,y) d \tau
\qquad \text{and} \qquad
\int_{y}^{y+t} f(a,\tau,y) d \tau 
\]</span> and are provided as annual matrices</p>
<ul>
<li><code>Ms</code> is an annual matrix of the unscaled integrated natural mortality;</li>
<li><code>Fs</code> is an annual matrix of the unscaled integrated fishing mortality,</li>
</ul>
<p>while the <em>scaled integrated</em> mortalities <span class="math display">\[
M_{y} \int_{y}^{y+t} m(a,\tau,y) d \tau
\qquad \text{and} \qquad
F_{y} \int_{y}^{y+t} f(a,\tau,y) d \tau 
\]</span> aand are provided as</p>
<ul>
<li><code>MMs</code> is an annual matrix of the scaled integrated natural mortality;</li>
<li><code>FFs</code> is an annual matrix of the scaled integrated fishing mortality.</li>
</ul>
<p>For some computations only the integration over the entire year is relevant. The final row of an annual matrix is called a <em>final vector</em>, and</p>
<ul>
<li><code>Msf</code> and <code>Fsf</code> denote the final vectors of the unscaled integrated mortalities, and</li>
<li><code>MMsf</code> and <code>FFsf</code> denote the final vectors of the scaled integrated mortalities.</li>
</ul>
<p>A forward projection over a year produces the projected abundance (number of individuals), biomass and optionally the yield. The projection functions return these as a list with components</p>
<ul>
<li><code>N</code> - an annual matrix of abundance</li>
<li><code>B</code> - an annual matrix of biomass, and optionally</li>
<li><code>Y</code> - either an annual matrix or final vector of yield.</li>
</ul>
<p>These matrices are then to produce various annual summaries as required.</p>
</div>
<div id="quadrature" class="section level2">
<h2>Quadrature</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">library</span>(Grym)</a></code></pre></div>
<p>Given a set of function values <span class="math inline">\(f(x_{k})\)</span> sampled at even increments <span class="math inline">\(x_{k} = x_{1}+(k-1) h\)</span>, the integral <span class="math inline">\(\int_{x_{1}}^{x_{n}} f(\tau) d\tau\)</span> can be approximated by the composite <a href="wikipedia.org/wiki/Trapezoidal_rule">trapezoidal rule</a> <span class="math display">\[
\int_{x_{1}}^{x_{n}} f(\tau) d\tau = \frac{h}{2}f(x_{1}) + h \sum_{k=2}^{n-1} f(x_{k}) + \frac{h}{2} f(x_{n})
\]</span> The <code>trapz</code> function implements the composite trapzoidal rule. Given a vector <code>fs</code> of function values <span class="math inline">\(f(x_{k})\)</span>, <code>trapz</code> returns the trapezoidal approximation to <span class="math inline">\(\int_{x_{1}}^{x_{n}} f(\tau) d\tau\)</span>. If <code>fs</code> is a matrix, then each column is assumed to represent a different integrand <span class="math inline">\(f(x)\)</span>, and <code>trapz</code> returns acts on the columns to return a vector of approximate integrals.</p>
<p>The <code>ctrapz</code> function is similar except that it returns the sequence of successive approximations <span class="math display">\[\left
( \int_{x_{1}}^{x_{1}} f(\tau) d\tau, \int_{x_{1}}^{x_{2}} f(\tau)
d\tau, \ldots, \int_{x_{1}}^{x_{n}} f(\tau) d\tau \right ).
\]</span><br />
The result is always the same size as <code>fs</code>.</p>
<p>With these definitions, if <code>ms</code> is a annual matrix of natural mortality, <code>fs</code> is a annual matrix of fishing mortality and <code>h</code> is the length of a time step, then annual matrices of integrated mortalities <span class="math display">\[ 
\int_{y}^{y+t} m(a,\tau,y) d \tau \qquad \text{and} \qquad \int_{y}^{y+t} f(a,\tau,y) d \tau
\]</span> can be computed as</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" title="1">Ms &lt;-<span class="st"> </span><span class="kw">ctrapz</span>(ms,h)</a>
<a class="sourceLine" id="cb2-2" title="2">Fs &lt;-<span class="st"> </span><span class="kw">ctrapz</span>(ms,h)</a></code></pre></div>
<p>The the various scaled and final integrated mortalities required for a projection can then be computed as</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" title="1">Mms &lt;-<span class="st"> </span>M<span class="op">*</span>ms</a>
<a class="sourceLine" id="cb3-2" title="2">Ffs &lt;-<span class="st"> </span>F<span class="op">*</span>fs</a>
<a class="sourceLine" id="cb3-3" title="3">MMs &lt;-<span class="st"> </span>M<span class="op">*</span>Ms</a>
<a class="sourceLine" id="cb3-4" title="4">FFs &lt;-<span class="st"> </span>F<span class="op">*</span>Fs</a>
<a class="sourceLine" id="cb3-5" title="5">Msf &lt;-<span class="st"> </span>Ms[<span class="kw">nrow</span>(Ms)]</a>
<a class="sourceLine" id="cb3-6" title="6">Fsf &lt;-<span class="st"> </span>Fs[<span class="kw">nrow</span>(Fs)]</a>
<a class="sourceLine" id="cb3-7" title="7">MMsf &lt;-<span class="st"> </span>MMs[<span class="kw">nrow</span>(MMs)]</a>
<a class="sourceLine" id="cb3-8" title="8">FFsf &lt;-<span class="st"> </span>FFs[<span class="kw">nrow</span>(FFs)]</a></code></pre></div>
</div>
<div id="annual-projection" class="section level2">
<h2>Annual Projection</h2>
<p>When both natural and fishing mortalities are known the computation to project across a single year is straightforward.</p>
<p>Given annual matrices <code>ms</code> and <code>fs</code> of unscaled mortalities, an annual matrix <code>ws</code> of weight at age and a vector <code>N0</code> of initial abundances for each age class, then projections of abundance <code>N</code>, biomass <code>B</code> and yield <code>Y</code> can be calculated as</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" title="1"><span class="co">## Integrate m and f over the year</span></a>
<a class="sourceLine" id="cb4-2" title="2">h &lt;-<span class="st"> </span><span class="fl">1.0</span><span class="op">/</span>(<span class="kw">nrow</span>(ms)<span class="op">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-3" title="3">Ms &lt;-<span class="st"> </span><span class="kw">ctrapz</span>(ms,h)</a>
<a class="sourceLine" id="cb4-4" title="4">Fs &lt;-<span class="st"> </span><span class="kw">ctrapz</span>(fs,h)</a>
<a class="sourceLine" id="cb4-5" title="5"></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="co">## Integrate N and scale by initial values</span></a>
<a class="sourceLine" id="cb4-7" title="7">N &lt;-<span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>M<span class="op">*</span>Ms<span class="op">-</span>F<span class="op">*</span>Fs)</a>
<a class="sourceLine" id="cb4-8" title="8"><span class="cf">for</span>(j <span class="cf">in</span> <span class="kw">seq_len</span>(<span class="kw">ncol</span>(N))) N[,j] &lt;-<span class="st"> </span>N0[j]<span class="op">*</span>N[,j]</a>
<a class="sourceLine" id="cb4-9" title="9">    </a>
<a class="sourceLine" id="cb4-10" title="10"><span class="co">## Scale by weight at age</span></a>
<a class="sourceLine" id="cb4-11" title="11">B &lt;-<span class="st"> </span>ws<span class="op">*</span>N </a>
<a class="sourceLine" id="cb4-12" title="12">  </a>
<a class="sourceLine" id="cb4-13" title="13"><span class="co">## Integrate yield</span></a>
<a class="sourceLine" id="cb4-14" title="14">Y &lt;-<span class="st"> </span><span class="kw">ctrapz</span>(F<span class="op">*</span>fs<span class="op">*</span>B,h)</a></code></pre></div>
<div id="known-fishing-mortality" class="section level3">
<h3>Known Fishing Mortality</h3>
<p>A minor generalization allows the projection to be scaled to abundance or total biomass estimates from a survey. The initial abundances simply scale the integrated profiles over time. If the number of individuals in each age class are known at some other reference time (for example through a survey), it suffices to integrate as before but adjust the scaling to reproduce the known abundance at the reference time. In some instances only relative cohort abundances are known at some reference time, but total biomass is known at some (possibly different) reference time and projections should be scaled to reproduce both the relative abindance and the known total biomass. In essence this back-projects the reference abundance or biomass to the start of the year.</p>
<p>The computation of yield is relatively expensive and is not always required, and so the <code>yield</code> flag allows the yield to be computed only for the final time step, all time steps, or not at all</p>
<p>Given</p>
<ul>
<li><code>ws</code> - matrix of weights at age</li>
<li><code>MMs</code> - matrix of scaled integrated natural mortalities</li>
<li><code>FFs</code> - matrix of scaled integrated fishing mortalities</li>
<li><code>Ffs</code> - matrix of scaled fishing mortalities</li>
<li><code>Nref</code> - vector of reference abundances for each age class</li>
<li><code>nref</code> - vector of time steps for which the reference abundance is known</li>
<li><code>Bref</code> - reference biomass</li>
<li><code>bref</code> - vector of time steps for which the reference biomass is known</li>
<li><code>yield</code> - if <code>yield=1</code> only calculate yeild for the final time step, if <code>yield=2</code> calculate yield for all time steps, otherwise yield is not caclulated at all</li>
</ul>
<p>the <code>project</code> function computes annual matrices of projected abundance <code>N</code>, biomass <code>B</code> and yield <code>Y</code>.</p>
<p>Given the assumptions of the model, the compuation of <code>N</code> and <code>B</code> are exact, but the trapezoidal approximation for <code>Y</code> will only be accurate if the total mortality in each time step is small.</p>
</div>
<div id="known-catch" class="section level3">
<h3>Known Catch</h3>
<p>In some cases the annual scaling of fishing mortality <span class="math inline">\(F_{y}\)</span> is unknown, and must be chosen to reproduce a given target yield.</p>
<p>The <code>projectC</code> function harnesses <code>project</code> in conjuction with the univariate root finder <code>uniroot</code> to determine the scaling of fishing mortality <span class="math inline">\(F_{y}\)</span> that reproduces an observed catch, and then projects forward for that scaling. If the target catch cannot be recovered without exceeding <code>Fmax</code>, the projection is performed with <code>F</code> capped at <code>Fmax</code>. No warning is issued and it is the responsibility of the user to check if <code>F==Fmax</code>.</p>
<p>Given</p>
<ul>
<li><code>ws</code> - matrix of weights at age</li>
<li><code>MMs</code> - matrix of scaled integrated natural mortalities</li>
<li><code>Fs</code> - matrix of unscaled integrated fishing mortalities</li>
<li><code>fs</code> - matrix of unscaled fishing mortalities</li>
<li><code>Catch</code> - target total annual catch</li>
<li><code>Nref</code> - vector of reference abundances for each age class</li>
<li><code>nref</code> - vector of time steps for which the reference abundance is known</li>
<li><code>Bref</code> - reference biomass</li>
<li><code>bref</code> - vector of time steps for which the reference biomass is known</li>
<li><code>yield</code> - if <code>yield=1</code> only calculate yeild for the final time step, if <code>yield=2</code> calculate yield for all time steps, otherwise yield is not caclulated at all</li>
<li><code>Fmax</code> - the maximum <code>F</code> to allow in the search</li>
<li><code>tol</code> - the precision to which to reproduce the observed catch</li>
</ul>
<p>the <code>projectC</code> function computes matrices of projected abundance <code>N</code>, biomass <code>B</code>, yield <code>Y</code> and annual scaling of fishing mortality <code>F</code> that reproduces the target catch</p>
</div>
<div id="age-progression" class="section level3">
<h3>Age Progression</h3>
<p>At the end of an annual projection, the initial abundances for the next projection are formed by filling the lowest age class with recruits and advancing the final projected cohort abundance by one age class. If the final class is a “plus” class, the individuals in the final age class of the projection are retained, otherwise these individuals are discarded.</p>
<p>Given</p>
<ul>
<li><code>N</code> - matrix of projected abundance</li>
<li><code>R</code> - number of recruits</li>
<li><code>plus</code> - is the final age class a “plus” class.</li>
</ul>
<p>the <code>advance</code> function determines the initial abundances for the next projection</p>
</div>
<div id="rescaling" class="section level3">
<h3>Rescaling</h3>
<p>An existing projection for a fixed <code>F</code> can be rescaled to match a reference abundance or biomass. If the natural and fishing mortalities do not vary inter-annually, it may be faster to compute an initial projection and repeatedly rescale than to continually reproject.</p>
<p>Given</p>
<ul>
<li><code>pr</code> - an exsiting projection</li>
<li><code>Nref</code> - vector of reference abundances for each age class</li>
<li><code>nref</code> - vector of time steps for which the reference abundance is known</li>
<li><code>Bref</code> - reference biomass</li>
<li><code>bref</code> - vector of time steps for which the reference biomass is known</li>
</ul>
<p>the <code>rescaleProjection</code> rescales the projection to match the prescribed reference abundance or biomass.</p>
</div>
</div>
<div id="size-and-maturity" class="section level2">
<h2>Size and Maturity</h2>
<p>Grym require matrices that map age at each time step to weight, maturity or selectivity. In principle these mappings are arbitrary and the user is free to specify these as they choose. For convenience, Grym implements a small number of common models for translating between age, length, weight and maturity, using the same parameterizations as used in the original GYM.</p>
<p>The von Bertalanffy growth model is often used to model length at age</p>
<p>The GYM also offers a variant in which growth is restricted to a fraction <span class="math inline">\([f_{0},f_{1}]\)</span> of each year</p>
<p>Length-weight replationships are often modelled as a power law</p>
<p>The GYM uses a piecewise linear “ramp” function to model selectivity and maturity - this is simply the distribution function of a uniform distribution</p>
</div>
<div id="initial-age-structure" class="section level2">
<h2>Initial Age Structure</h2>
<p>The initial age structure from which to start a projection can be calculated:</p>
<ol style="list-style-type: decimal">
<li>by back-projecting abundance from the age structure observed in a survey (as in <code>project</code>),</li>
<li>deterministically assuming mortality and recruitment do not vary inter-annually, or</li>
<li>stochastically by projecting abundance forward assuming random recruitment.</li>
</ol>
<div id="deterministic-age-structure" class="section level3">
<h3>Deterministic Age Structure</h3>
<p>To determine the deterministic equilibrium age structure it is necessary to assume natural mortality and fishing mortality do not vary inter-annually, but may vary intra-annually and with age.</p>
<p>As <span class="math inline">\(M_{y}\)</span> and <span class="math inline">\(F_{y}\)</span> do not vary across seasons, it suffices to compute the survival for each age class across a single year, and then compute the cumulative survival for each age class. If the last age class is a plus class, we extend the single year survivals to allow for the additional age classes captured by the plus class. This only constructs a relative age structure, which must be scaled by the mean recruitment</p>
<p>Given</p>
<ul>
<li><code>MMsf</code> - vector of final scaled integrated natural mortalities</li>
<li><code>FFsf</code> - vector of final scaled integrated fishing mortalities</li>
<li><code>R</code> - mean number of recruits</li>
<li><code>plus</code> - the number of additional age classes in the plus class (<code>plus=0</code> implies no plus class).</li>
</ul>
<p>the <code>ageStructureD</code> function returns the corresponding vector of equilibrium abundances</p>
</div>
<div id="stochastic-age-structure" class="section level3">
<h3>Stochastic Age Structure</h3>
<p>To stochastically determine an initial age structure it suffices to project forward for at least as many years as there are age classes with non neglible numbers (including age classes aggregated into the plus group).</p>
<p>This routine optimizes for when there is no inter-annual variability in the natural and fishing mortality, in which case the survival of each age class over a single year is constant and can be precomputed.</p>
<p>Given</p>
<ul>
<li><code>R</code> - vector of yearly recruitment numbers</li>
<li><code>Msf</code> - vector of final unscaled integrated natural mortalities</li>
<li><code>M</code> - vector of annual natural mortalities</li>
<li><code>Fsf</code> - vector of final unscaled integrated fishing mortalities</li>
<li><code>F</code> - vector of annual fishing mortalities</li>
<li><code>plus</code> - whether the final class is a “plus” class</li>
</ul>
<p>the <code>ageStructureS</code> function returns a random initial vector of abundances</p>
</div>
</div>
<div id="stock-summaries" class="section level2">
<h2>Stock Summaries</h2>
<p>The spawning stock abundance and biomass are the determined from the projected abundance and biomass by scaling by the expected fraction mature at age and summing the contribution from each age class averaged over the spawning period.</p>
<p>Given</p>
<ul>
<li><code>P</code> - matrix of projected abundance or biomass</li>
<li><code>gs</code> - matrix of fraction mature at age</li>
<li><code>period</code> - the time steps corresponding to the spawning period</li>
</ul>
<p>the <code>spawningStock</code> function returns the mean spawning stock abundance or biomass</p>
<p>The stock abundance and biomass that are vulnerable to fishing are the determined from the projected abundance and biomass by scaling by the selectivity at age and summing the contribution from each age class averaged over the monitoring period.</p>
<p>Given</p>
<ul>
<li><code>P</code> - matrix of projected abundance or biomass</li>
<li><code>ss</code> - matrix of selectivity at age</li>
<li><code>period</code> - the time steps corresponding to the monitoring period</li>
</ul>
<p>the <code>vulnerableStock</code> function returns the mean vulnerable stock abundance or biomass</p>
<p>Within the GYM, the vulnerable stock is calculated by weighting by the within year fishing effort for the monitoring period. Given</p>
<ul>
<li><code>fwy</code> - vector of within year distribution of effort for the year.</li>
<li><code>ss</code> - matrix of selectivity at age</li>
<li><code>P</code> - matrix of projected abundance or biomass</li>
<li><code>period</code> - the time steps corresponding to the monitoring period</li>
</ul>
<p>the <code>vulnerableStockGYM</code> function returns the effort weighted mean vulnerable stock abundance or biomass</p>
<div id="deterministic-virgin-spawning-bomass" class="section level3">
<h3>Deterministic Virgin Spawning Bomass</h3>
<p>A deterministic estimate of the virgin spawning biomass is obtained by deterministically computing the initial age structure and projecting forward to determine the spawning stock biomass.</p>
<p>Given</p>
<ul>
<li><code>gs</code> - matrix of fraction mature at age</li>
<li><code>MMsf</code> - vector of final scaled integrated natural mortalities</li>
<li><code>spawn</code> - the time steps corresponding to the spawning period</li>
<li><code>R</code> - the mean numbers of recruits</li>
<li><code>plus</code> - the number of additional age classes in the plus class (<code>plus=0</code> implies no plus class).</li>
</ul>
<p>the <code>ageStructureD</code> function returns the corresponding vector of equilibrium abundances</p>
</div>
<div id="stochastic-virgin-spawning-bomass" class="section level3">
<h3>Stochastic Virgin Spawning Bomass</h3>
<p>A stochastic estimate of the virgin spawning biomass is obtained by repeatedly simulating an initial age structure and projecting forward to simulate a spawning stock biomass. The median, mean and standard deviation of the simulated spawning biomasses are returned.</p>
<p>Given</p>
<ul>
<li><code>R</code> - matrix or yearly recruitment numbers</li>
<li><code>gs</code> - matrix of fraction mature at age</li>
<li><code>Ms</code> - marix of unscaled integrated natural mortalities</li>
<li><code>M</code> - vector of annual natural mortalities</li>
<li><code>spawn</code> - the time steps corresponding to the spawning period</li>
<li><code>plus</code> - whether the final class is a “plus” class</li>
</ul>
<p>the <code>spawningB0S</code> function returns the median, mean and standard deviation of the simulated virgin spawning biomasses</p>
</div>
</div>
<div id="recruitment" class="section level2">
<h2>Recruitment</h2>
<p>The GYM offers a number of options for modelling recruitment including drawing from a log Normal distribution, bootstrapping from a known time series of recruitments, or the proportional recruitment model described in <span class="citation">de la Mare (1994)</span>.</p>
<div id="proportional-recruitment-gym" class="section level3">
<h3>Proportional Recruitment (GYM)</h3>
<p>These following functions replicate the algorithms for proportional recruitment implemented in the GYM and described in <span class="citation">de la Mare (1994)</span>. The implementation in the GYM differs slightly from <span class="citation">de la Mare (1994)</span> in the expressions used for bias correction.</p>
<p>Assume the population recruits to the first age class, and let <span class="math inline">\(A_{k}\)</span> denote the number of individuals currently in age class <span class="math inline">\(k\)</span>, and let <span class="math inline">\(R\)</span> denote the number of individuals in age class <span class="math inline">\(r\)</span> as a proportion of all individuals of that age or older <span class="math display">\[
R = \frac{A_{r}}{\sum_{k=r} A_{k}}.
\]</span></p>
<p>Then given estimates of the mean <span class="math inline">\(\mu_{R}\)</span> and variance <span class="math inline">\(\sigma^{2}_{R}\)</span> of <span class="math inline">\(R\)</span> derived from independent surveys, the proportional recruitment model generates random number of recruits that would reproduce the observed values of the mean <span class="math inline">\(\mu_{R}\)</span> and variance <span class="math inline">\(\sigma^{2}_{R}\)</span> of the proportion <span class="math inline">\(R\)</span>.</p>
<p>Given</p>
<ul>
<li><code>mnR</code> - an estimate of the mean of <span class="math inline">\(R\)</span> from independent surveys</li>
<li><code>vrR</code> - an estimate of the variance of <span class="math inline">\(R\)</span> from independent surveys</li>
<li><code>Msf</code> - vector of final unscaled integrated natural mortalities</li>
<li><code>r</code> - the reference age class</li>
<li><code>plus</code> - the number of additional age classes in the plus class (<code>plus=0</code> implies no plus class).</li>
<li><code>Mbrak</code> - the values of natural mortality to assess when bracketing a root for the nonlinear solver</li>
<li><code>tol</code> - the tolerance for nonlinear solver</li>
</ul>
<p>the <code>prRecruitParsGYM</code> function generates the parameters needed to draw random numbers of recruits.</p>
<p>Given</p>
<ul>
<li><code>n</code> - the number of recruitment events</li>
<li><code>ps</code> - a list of parameters returned by <code>prRecruitParGYM</code></li>
<li><code>mnA</code> - the mean number of recruits</li>
</ul>
<p>the <code>prRecruitsGYM</code> function generates the corresponding random numbers of recruits. Note that the bias correction can lead to negative deviates and so a rejection scheme is used to draw only positive deviates, but this results in bias.</p>
</div>
<div id="proportional-recruits" class="section level3">
<h3>Proportional Recruits</h3>
<p>Grym offers a formulation of proportional recruitment model that differs from that described in <span class="citation">de la Mare (1994)</span>.</p>
<p>Assume the population recruits to the first age class, and let <span class="math inline">\(A_{k}\)</span> denote the number of individuals currently in age class <span class="math inline">\(k\)</span>, <span class="math inline">\(a_{k}\)</span> the number of individuals originally recruited to that cohort, and <span class="math inline">\(S_{k}\)</span> the survival from recruitment to the current time so that for each age class <span class="math inline">\(A_{k} = a_{k} S_{k}\)</span>, and <span class="math inline">\(A_{1}=a_{1}\)</span> with <span class="math inline">\(S_{1}=1\)</span>.</p>
<p>As in <span class="citation">de la Mare (1994)</span>, let <span class="math inline">\(R\)</span> denote the number of individuals in age class <span class="math inline">\(r\)</span> as a proportion of the population of individuals of the same age or older <span class="math display">\[
R = \frac{A_{r}}{\sum_{k=r} A_{k}} = \frac{a_{r} S_{r}}{\sum_{k=r} a_{k} S_{k}}=\frac{a_{r}}{a_{r} +S_{r}^{-1}\sum_{k=r+1} a_{k} S_{k}} 
\]</span> and suppose estimates of the mean <span class="math inline">\(\mu_{R}\)</span> and variance <span class="math inline">\(\sigma^{2}_{R}\)</span> of <span class="math inline">\(R\)</span> can be derived from independent surveys.</p>
<p>The model simulates numbers of recruits <span class="math inline">\(a_{1}\)</span> as a stochastic fraction <span class="math inline">\(Q\)</span> of the expected number of individuals above recruitment age <span class="math display">\[
a_{1} = Q \operatorname{E}\left ( \sum_{k=2} A_{k} \right ),
\]</span> where the mean <span class="math inline">\(\mu_{Q}\)</span> and variance <span class="math inline">\(\sigma^{2}_{Q}\)</span> of <span class="math inline">\(Q\)</span> are chosen to reproduce the observed <span class="math inline">\(\mu_{R}\)</span> and <span class="math inline">\(\sigma^{2}_{R}\)</span>. In this model <span class="math inline">\(Q\)</span> can be interpreted as the odds of recruits.</p>
<p>Assuming the numbers of recruits each year are independently and identically distributed with mean <span class="math inline">\(\mu_{a}\)</span>, <span class="math display">\[
a_{1} = Q \operatorname{E}\left ( \sum_{k=2} a_{k} S_{k} \right ) = Q \mu_{a} \sum_{k=2} S_{k}.
\]</span></p>
<p>Taking the expected value of both sides of this relation <span class="math display">\[
\mu_{a}  = \mu_{Q} \mu_{a} \sum_{k=2} S_{k}
\]</span> shows that the natural mortality <span class="math inline">\(M\)</span> must be chosen to give survivals <span class="math inline">\(S_{k}\)</span> such that <span class="math display">\[
\mu_{Q} = \left ( \sum_{k=2} S_{k}\right )^{-1}.
\]</span></p>
<p>Define the sums <span class="math display">\[
\begin{align}
  s_{0}&amp;=\sum_{k=2} S_{k}\\
  s_{1}&amp;=S_{r}^{-1}\sum_{k=r+1} S_{k}\\
  s_{2}&amp;=S_{r}^{-2}\sum_{k=r+1} S_{k}^{2}.
\end{align}         
\]</span> Then approximately <span class="math display">\[
\begin{align}
\mu_{R} 
&amp;=\frac{\operatorname{E}(a_{r}S_{r})}{\operatorname{E}\left (\sum_{k=r} a_{k} S_{k}\right )} 
-\frac{\operatorname{Cov}(a_{r}S_{r},\sum_{k=r} a_{k} S_{k})}{\operatorname{E}\left (\sum_{k=r} a_{k} S_{k}\right )^{2}}+
\frac{\operatorname{E}(a_{r}S_{r})\operatorname{Var}\left ( \sum_{k=r} a_{k} S_{k}\right )}{\operatorname{E}\left (\sum_{k=r} a_{k} S_{k}\right )^{3}}
\\
&amp;=\frac{\mu_{a}S_{r}}{\mu_{a}\sum_{k=r} S_{k}} 
-\frac{\sigma_{a}^{2}S_{r}^{2}}{\left (\mu_{a}\sum_{k=r} S_{k}\right )^{2}}+
\frac{\mu_{a} \sigma_{a}^{2}S_{r}\sum_{k=r} S_{k}^{2}}{\left (\mu_{a}\sum_{k=r} S_{k}\right )^{3}}
\\
&amp;=\frac{\mu_{a}}{\mu_{a}(1+s_{1})} 
-\frac{\sigma_{a}^{2}}{\mu_{a}^{2}(1+s_{1})^{2}}+
\frac{\mu_{a} \sigma_{a}^{2}(1+s_{2})}{\mu_{a}^{3}(1+s_{1})^{3}}
\\
&amp;=\frac{1}{(1+s_{1})}+
\frac{\sigma_{a}^{2}(s_{2}-s_{1})}{\mu_{a}^{2}(1+s_{1})^{3}}
\end{align}
\]</span> and <span class="math display">\[
\begin{align}
\sigma_{R}^{2}
&amp;=\frac{\operatorname{E}(a_{r}S_{r})^{2}}{\operatorname{E}\left (\sum_{k=r} a_{k} S_{k}\right )^{2}} 
\left [
\frac{\operatorname{Var}(a_{r}S_{r})}{\operatorname{E}(a_{r}S_{r})^{2}}
-2\frac{\operatorname{Cov}(a_{r}S_{r},\sum_{k=r} a_{k} S_{k})}{\operatorname{E}(a_{r}S_{r})\operatorname{E}\left (\sum_{k=r} a_{k} S_{k}\right )}+
\frac{\operatorname{Var}\left ( \sum_{k=r} a_{k} S_{k}\right )}{\operatorname{E}\left (\sum_{k=r} a_{k} S_{k}\right )^{2}}
\right ]\\
&amp;=\frac{\mu_{a}^{2}}{\mu_{a}^{2}(1+s_{1})^{2}} 
\left [
\frac{\sigma_{a}^{2}}{\mu_{a}^{2}}
-\frac{2\sigma_{a}^{2}}{\mu_{a}^{2}(1+s_{1})}+
\frac{\sigma_{a}^{2}(1+s_{2})}{\mu_{a}^{2}(1+s_{1})^{2}}
\right ]\\
&amp;=\frac{\sigma_{a}^{2}(s_{1}^{2}+s_{2})}{\mu_{a}^{2}(1+s_{1})^{4}},
\end{align}
\]</span> from which it is deduced <span class="math display">\[
\sigma_{a}^{2}=\frac{\mu_{a}^{2}\sigma_{R}^{2}(1+s_{1})^{4}}{(s_{1}^{2}+s_{2})}.
\]</span> and hence <span class="math display">\[
\mu_{R} =\frac{1}{(1+s_{1})}+
\frac{(1+s_{1})(s_{2}-s_{1})\sigma_{R}^{2}}{s_{1}^{2}+s_{2}}.
\]</span></p>
<p>As <span class="math inline">\(s_{1}\)</span> and <span class="math inline">\(s_{2}\)</span> are functions of natural mortality <span class="math inline">\(M\)</span>, this expression can be solved for <span class="math inline">\(M\)</span> and hence <span class="math inline">\(s_{1}\)</span> and <span class="math inline">\(s_{2}\)</span>, and hence <span class="math display">\[
\begin{align}
\mu_{Q} &amp;= s_{0}^{-1}\\
\sigma_{Q}^{2} &amp;= \frac{(1+s_{1})^{4} \sigma_{R}^{2}}{s_{0}^{2}(s_{1}^{2}+s_{2})}.
\end{align}
\]</span></p>
<p>These expressions determine the mean and variance of the stochastic fraction <span class="math inline">\(Q\)</span> required to reproduce the <span class="math inline">\(\mu_{R}\)</span> and <span class="math inline">\(\sigma^{2}_{R}\)</span> observed in surveys. The fraction <span class="math inline">\(Q\)</span> may have any distribution with mean <span class="math inline">\(\mu_{Q}\)</span> and variance <span class="math inline">\(\sigma_{Q}^{2}\)</span> that has the positive real line as support.</p>
<p>The equation above is solved for natural mortality using a standard bisection procedure after first bracketing the root by evaluating the equation at a set of mortalities provided by the user.</p>
<p>Given</p>
<ul>
<li><code>mnR</code> - an estimate of the mean of <span class="math inline">\(R\)</span> from independent surveys</li>
<li><code>vrR</code> - an estimate of the variance of <span class="math inline">\(R\)</span> from independent surveys</li>
<li><code>Msf</code> - vector of final unscaled integrated natural mortalities</li>
<li><code>r</code> - the reference age class</li>
<li><code>plus</code> - the number of additional age classes in the plus class (<code>plus=0</code> implies no plus class).</li>
<li><code>Mbrak</code> - the values of natural mortality to assess when bracketing a root for the nonlinear solver</li>
<li><code>tol</code> - the tolerance for nonlinear solver</li>
</ul>
<p>the <code>prRecruitPars0</code> function generates the mean and variance of <span class="math inline">\(Q\)</span>, and the sum <span class="math inline">\(s_{0}\)</span> required by the proportional recruitment model, and is used to define specific families of random recruitments below</p>
<div id="inverse-beta" class="section level4">
<h4>Inverse Beta</h4>
<p>The model implemented in the GYM assumes the proportion of recruits is Beta distributed, and the natural analog in the model considered here is to assume the odds of recruits <span class="math inline">\(Q\)</span> has an inverse Beta distribution.</p>
<p>If the proportion <span class="math inline">\(R\)</span> is Beta distributed with shape parameters <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, then the corresponding odds <span class="math inline">\(Q = \frac{R}{1-R}\)</span> will be inverse Beta distributed with the same parameters <span class="math display">\[
Q \sim \operatorname{Beta}^{\prime}(a,b),
\]</span> with mean <span class="math inline">\(\mu_{Q}=\operatorname{E}(Q)\)</span> and variance <span class="math inline">\(\sigma_{Q}^{2}=\operatorname{Var}(Q)\)</span> <span class="math display">\[
\begin{align}
\mu_{Q} &amp;= \frac{a}{b-1}\\
\sigma_{Q}^{2} &amp;= \frac{a (a+b-1)}{(b-2)(b-1)^{2}}
\end{align}
\]</span> The shape parameters the yield a given mean and variance are <span class="math display">\[
\begin{align}
a &amp;= \frac{\mu_{Q}(\mu_{Q}(1+\mu_{Q})+\sigma_{Q}^{2})}{\sigma_{Q}^{2}}\\
b &amp;= \frac{\mu_{Q}(1+\mu_{Q})+2\sigma_{Q}^{2}}{\sigma_{Q}^{2}}.
\end{align}
\]</span></p>
<p>The <code>prRecruitParsIB</code> variant generates the parameters for the proportional recruitment model assuming the fraction of recruits has an inverse Beta distribution</p>
<p>and <code>prRecruitsIB</code> generates the corresponding random numbers of recruits</p>
<p>The <code>prRecruitParsDIB</code> variant generates the parameters for the proportional recruitment model assuming the fraction of recruits has a “delta” inverse Beta distribution in which a fraction <code>p</code> of events yield zero recruits</p>
<p>and <code>prRecruitsDIB</code> generates the corresponding random numbers of recruits</p>
</div>
<div id="gamma" class="section level4">
<h4>Gamma</h4>
<p>If the fraction <span class="math inline">\(Q\)</span> is assumed to be Gamma distributed with shape parameters <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> <span class="math display">\[
Q \sim \operatorname{Gamma}(a,b),
\]</span> then <span class="math display">\[
\begin{align}
a &amp;= \frac{\mu_{Q}^{2}}{\sigma_{Q}^{2}}\\
b &amp;= \frac{\mu_{Q}}{\sigma_{Q}^{2}}
\end{align}
\]</span></p>
<p>The <code>prRecruitParsG</code> variant generates the parameters for the proportional recruitment model assuming the fraction of recruits is Gamma distributed</p>
<p>and <code>prRecruitsG</code> generates the corresponding random numbers of recruits</p>
<p>The <code>prRecruitParsDG</code> variant generates the parameters for the proportional recruitment model assuming the fraction of recruits is “delta” Gamma distributed in which a fraction <code>p</code> of events yield zero recruits</p>
<p>and <code>prRecruitsDG</code> generates the corresponding random numbers of recruits</p>
</div>
<div id="log-normal" class="section level4">
<h4>Log Normal</h4>
<p>If the fraction <span class="math inline">\(Q\)</span> is assumed to have a log Normal distribution with parameters <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\sigma^{2}\)</span> <span class="math display">\[
Q \sim \operatorname{LogNormal}(\mu,\sigma^2),
\]</span> then <span class="math display">\[
\begin{align}
\mu &amp;= \log \frac{\mu_{Q}^{2}}{\mu_{Q}^{2} + \sigma_{Q}^{2}}\\
\sigma^{2} &amp;= \log \frac{\mu_{Q}^{2} + \sigma_{Q}^{2}}{\mu_{Q}^{2}}\\
\end{align}
\]</span> The <code>prRecruitParsLN</code> variant generates the parameters for the proportional recruitment model assuming the fraction of recruits is log Normal</p>
<p>and <code>prRecruitsLN</code> generates the corresponding random numbers of recruits</p>
<p>The <code>prRecruitParsDLN</code> variant generates the parameters for the proportional recruitment model assuming the fraction of recruits is “delta” log Normal in which a fraction <code>p</code> of events yield zero recruits</p>
<p>and <code>prRecruitsDLN</code> generates the corresponding random numbers of recruits</p>
</div>
</div>
<div id="variability-in-survey-estimates" class="section level3">
<h3>Variability in Survey Estimates</h3>
<p>To account for uncertainly in the survey based estimates of the mean and variance of <span class="math inline">\(R\)</span>, <span class="citation">de la Mare (1994)</span> suggests simulating new values for mean <span class="math inline">\(R\)</span> from a Normal distribution and new values for the variance of <span class="math inline">\(R\)</span> from a Chi-squared distribution. But <span class="math inline">\(R\)</span> is a proportion and so has bounded variance, so simulating from a Chi-squared distribution is extremely inadvisable. It is almost certainly this procedure that is cause of the failure reported in <span class="citation">Kinzey, Watters, and Reiss (2013)</span>.</p>
<div id="gym" class="section level4">
<h4>GYM</h4>
<p>The following function implements the procedure used in the GYM to resample the mean and variance of <span class="math inline">\(R\)</span>. Note that the prescription in <span class="citation">de la Mare (1994)</span> erroneously uses the standard deviation not the standard error of the mean when resampling for <span class="math inline">\(R\)</span>.</p>
<p>This function should not be used as it generates variances that are impossibly large</p>
</div>
<div id="bootstrap" class="section level4">
<h4>Bootstrap</h4>
<p>As an alternative, Grym uses parametric bootstrap to simulate new values for the mean and variance of <span class="math inline">\(R\)</span> that are consistent with the observed values. If the original mean and variance were estimated from <span class="math inline">\(n\)</span> independent surveys, random recruits based on the observed mean and variance are used to generate <span class="math inline">\(n\)</span> new age structures from which <span class="math inline">\(R\)</span> and hence the mean and variance of <span class="math inline">\(R\)</span> are estimated. This procedure is guaranteed to produce realistic variances</p>
<p>Given</p>
<ul>
<li><code>prRec</code> - a function for generating random number of recruits from a proportional recruitment model</li>
<li><code>ps</code> - a list of model parameters</li>
<li><code>n</code> - the number of independent surveys used in the estimation of the mean and variance of R</li>
<li><code>Msf</code> - vector of final unscaled integrated natural mortalities</li>
<li><code>r</code> - the reference age class</li>
<li><code>plus</code> - the number of additional age classes in the plus class (<code>plus=0</code> implies no plus class).</li>
</ul>
<p>the <code>prBootstrap</code> function generates new values for the mean and variance of <span class="math inline">\(R\)</span>.</p>
</div>
</div>
</div>
<div id="survival-to-survey-period" class="section level2">
<h2>Survival to survey period</h2>
<p>The <code>surveySurvival</code> function determines the total surival from recruitment to a nominated survey period. This can be used to backproject age specific abundance survey data to estimate annual recruitments.</p>
<p>When there is inter-annual variability in natural or fishing mortality, the annual mortality scalings (<code>M</code> and/or <code>F</code>) are specified as vectors, and it is assumed that survey years are labelled so that <code>yr==1</code> corresponds to the year of the first elemnt of <code>M</code> or <code>F</code>. Survival cannot be computed for cohorts recruited before year 1.</p>
<p>When there is no inter-annual variability in natural or fishing mortality and the vectors <code>M</code> and <code>F</code> are both of length one, the survey year is essential irrelevant and is ignored.</p>
<p>Given</p>
<ul>
<li><code>Ms</code> - matrix of unscaled integrated natural mortalities</li>
<li><code>M</code> - vector of annual natural mortalities</li>
<li><code>Fs</code> - matrix of unscaled integrated fishing mortalities</li>
<li><code>F</code> - vector of annual fishing mortalities</li>
<li><code>yr</code> - vector of the survey year</li>
<li><code>cls</code> - vector of age classes surveyed</li>
<li><code>s1</code>, <code>s2</code> - vector of the start and end time step of the survey</li>
</ul>
<p>the <code>surveySurvival</code> function generates the total survival from time of recruitment to the first age class to the survey period.</p>
</div>
<div id="todo" class="section level2">
<h2>TODO</h2>
<p>Some basic functionality still needs to be implemented, including</p>
<ul>
<li>Parametric bootstrap from a vector of recruits</li>
</ul>
</div>
<div id="issues" class="section level2">
<h2>Issues</h2>
<div id="caching" class="section level4">
<h4>Caching</h4>
<p>The code has been optimized to make the very low level projection function as cheap to compute as possible. In large part this has been done by requiring the user to precompute various matrices of natural and fishing mortality that are likely to remain constant across projections.</p>
<p>But the cost of this strategy is that it complicates the argument lists of the functions, and similar functions can expect sublty different arguments, which is likely to lead to programming errors. It may be better to unify the argument lists across functions a little more at the cost of recomputing some expressions that are not too expensive to compute.</p>
</div>
<div id="normalization" class="section level4">
<h4>Normalization</h4>
<p>The GYM standardises the natural and fishing mortalities according to specific rules, but it is not clear that these rules are consistent if the fishing season is allowed to change inter-annually. In Grym, we have not formalized the standardizaiton in any way, we have left it up to the programmer to standardize as they see fit.</p>
</div>
<div id="averages" class="section level4">
<h4>Averages</h4>
<p>Arguably, the <code>mean</code> in <code>project</code> that computes the average over the reference interval should be an integral over the interval computed with <code>trapz</code> rather than a simple mean. Similar arguments apply to the calculation of stock averages such as spawning biomass and vulnerable biomass.</p>
<p>This would break consistency with the GYM, but be more internally consistent.</p>
</div>
<div id="runge-kutta" class="section level4">
<h4>Runge Kutta</h4>
<p>In the GYM projection is based on integrating a set of ODE’s with a Runge-Kutta procedure, but the implmentation seems oddly inaccurate. For example - when calculating median SB0, the GYM projects forward with unit abundance in each age class with no fishing mortality. Even though mortalities and initial abundances are identical, inspection with a single step debugger shows the Runge-Kutta produces projected abundances that differ cross age groups in the fifth or sixth significant figure. A Runge-Kutta procedure should be more accurate than this.</p>
</div>
<div id="plus-class" class="section level4">
<h4>Plus Class</h4>
<p>In some functions Grym treats age as potentially unlimited so that the plus class contains potentially infinitely many age classes. But in others Grym treats the plus class as containing only finitely many ages and the user must specify how many “additional” age classes reside in the plus class essentially placing an upper limit on the age of an individual. The two sets of functions can be distinguished by whether the <code>plus</code> argument is bolean (infinite age) or integer (finite age).</p>
<p>In one sense this is not really a problem in that the number of additional age classes can be set arbitrarily large (at the cost of computational effort), but it would be better if there were more consistency.</p>
<p>There are three main cases to consider:</p>
<ol style="list-style-type: decimal">
<li><p>In repeated yearly projections, any individual that enters the plus class “loses” its age, so in principle an individual in the plus class can be infinitely old. In practice this does not happen, the upper age will always be limited by the number of previous years of recruitment simulated.</p></li>
<li><p>If there is no inter-annual variability in mortalities, then it is possible to analytically determine quantities such as initial age structure and long term survival for arbitrary age limits ages in the plus group. For example <code>ageStructureD</code> will compute an initial age structure allowing an arbitrary limit on the number of additional age classes in the plus group.</p></li>
<li><p>But in the presence of inter-annual variability, it is not possible to determine simple analytic expressions for the age structure and an initial age structure must be computed by simulation. In this case maximum age in the plus class is determined by how many years of recruitment the simulation is based on.</p></li>
</ol>
</div>
<div id="summary-functions" class="section level4">
<h4>Summary Functions</h4>
<p>The summary functions Grym provides need to be thought through carefully to provide a sensible balance between utility and efficiency.</p>
<ul>
<li><p>should <code>initial</code> and <code>final</code> have an option to sum across age classes?</p></li>
<li><p>should <code>meanStock</code>, <code>spawningStock</code>, <code>exploitableStock</code> and <code>vulnerableStock</code> have an option to not sum across age classes but produce age class specific results?</p></li>
</ul>
</div>
<div id="proportional-recruitment" class="section level4">
<h4>Proportional Recruitment</h4>
<p>The proportional recruitment model used within the GYM is in itself workable, although Grym offers more general alternatives with better bias correction.</p>
<p>But the process for resampling the mena and variance of <span class="math inline">\(R\)</span> proposed in <span class="citation">de la Mare (1994)</span> is not reasonable and leads to impossible variances. Grym proposes a parametric bootstrap alternative, but as with all bootstrap approaches it is like to underestimate variability, and there may be better alternatives.</p>
</div>
<div id="memory-management" class="section level4">
<h4>Memory Management</h4>
<p>Memory management in the current implementation of R is oddly temperamental, and so some care needs to be taken when writing projection code.</p>
<p>Commonly we wish to project forward over several years and collate annual summaries. But if we preallocate a dataframe to store the summaries, then repeatedly project forward writing annual summary to the appropriate row of the dataframe, R performs an unnecessary copy fo teh data frame each time a row is written. If instead we allocate vectors for each separate summary quantity, and then bind these together as a dataframe when the projection is complete, the level of copying is vastly reduced. There is a helpful disccusion on this <a href="https://www.brodieg.com/2019/02/18/an-unofficial-reference-for-internal-inspect/">blog</a></p>
<p>As a general rule, it is more efficient to</p>
<ul>
<li><p>store results to vectors that are then bound together to form a dataframe rather than allocate dataframes and write inidividual results to that dataframe, and</p></li>
<li><p>create many small dataframes that summarize a small number of projections, and bind these together to create the final result.</p></li>
</ul>
<p>The upshot is that the most efficient code is not always the cleanest/most obvious.</p>
</div>
</div>
<div id="references" class="section level2 unnumbered">
<h2>References</h2>
<div id="refs" class="references">
<div id="ref-GYM96">
<p>Constable, AJ, and WK de la Mare. 1996. “A Generalised Model for Evaluating Yield and the Long-Term Status of Fish Stocks Under Conditions of Uncertainty.” <em>CCAMLR Science</em> 3: 31–54.</p>
</div>
<div id="ref-DLMrecruit94">
<p>de la Mare, WK. 1994. “Modelling Krill Recruitment.” <em>CCAMLR Science</em> 1: 49–54.</p>
</div>
<div id="ref-Kinzey13">
<p>Kinzey, Douglas, George Watters, and CS Reiss. 2013. “Effects of Recruitment Variability and Natural Mortality on Generalised Yield Model Projections and the Ccamlr Decision Rules for Antarctic Krill.” <em>CCAMLR Sci</em> 20: 81–96.</p>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
