---
title: "Grym"
output: rmarkdown::html_vignette
bibliography: Ref.bib
vignette: >
  %\VignetteIndexEntry{Grym}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = NA
)
```


```{r,echo=FALSE}
knitr::read_chunk("Grym.R")
```


## Introduction

Motivational text.  Reference @GYM96.


## History

History of KYM/GYM.


## Projection

The core functionality of the GYM is to project stock abundance, biomass and yield in each age class
forward in time over a single year.

The GYM projects stock abundance, biomass and yield forward over time by integrating a system of
differential equations with an adpative Runge-Kutta scheme. The GYM assumes the number \(N_{a,y}\),
biomass \(B_{a,y}\) and yield \(Y_{a,y}\) of individuals of age \(a\) in year \(y\) satisfy the
sytem of differential equations (@GYM96)
\[
\begin{align}
\frac{dN_{a,y}}{dt} &= - \Big [ M_{y} m(a,t,y)  + F_{y} f(a,t,y) \Big ] N_{a,y}\\
\frac{dB_{a,y}}{dt} &= w(a+t)\frac{dN_{a,y}}{dt} + N_{a,y}(t) \frac{dw(a+t)}{dt}\\
\frac{dY_{a,y}}{dt} &= F_{y} f(a,t,y) B_{a,y}
\end{align}
\]
where \(w(a+t)\) represents the weight at total age \(a+t\), and the total natural mortality
\(M_{y} m(a,t,y) \) has been decomposed into an annually varying component \(M_{y}\) and a component
\(m(a,t,y)\) that varies within years, and similarly the total fishing mortality \(F_{y} f(a,t,y) \)
has been decomposed into an annual component \(F_{Y}\) and a component \(f(a,t,y)\) that varies
within years.  To ensure identifiability of the parameters, an appropriate normalization must be
chosen for the within year components of mortality. The total yield in each year is the sum of the
contributions from each age class 
\[
Y_{y} = \sum_{a} Y_{a,y}(1).  
\]

The GYM solves this system of differential equations for each year by assuming the time varying
functions \(m(a,t,y)\), \(f(a,t,y)\) and \(w(a+t)\) are piecewise linear, and integrating the system
with an adaptive Runge-Kutta scheme.

Grym takes a more direct approach. The system of governing equations has solution
\[
\begin{align}
N_{a,y}(t) &= N_{a,y}(0)\exp \left [ - M_{y} \int_{y}^{y+t} m(a,\tau,y) d \tau  -  F_{y} \int_{y}^{y+t}f(a,\tau,y) d \tau\right ]\\
B_{a,y}(t) &= w(a+t) N_{a,y}(t)\\
Y_{a,y}(t) &= \int_{y}^{y+t}F_{y}f(a,\tau,y)B_{a,y}(\tau) d \tau.
\end{align}
\]
Grym uses this solution directly, evaluating the required integrals by numerical quadrature.  As
\(m(a,t,y)\) and \(f(a,t,y)\) are assumed piecewise linear, the composite trapezoidal rule will
yield exact solutions for \(N_{a,y}\) and \(B_{a,y}\).



## Data Structures and Notation

Within a projection over a single year, the main model parameters and start variables are stored as
matrices with an entry for each time step and modelled age class.  The naming of these quantities is
consistent throughout the Grym source code and examples, and is described in detail here. 


An *annual matrix* is a matrix with one row for the initial time and each subsequent time step
through the year, and one column for each modelled age class. For example, if a year is assumed to
consist of 365 days and a daily time step is adopted, each annual matrix will have 366 rows with the
first row representing to midnight on the last day of the previous year, and the last row
representing midnight on the final day of the current year.  Only modelled ages classes are
represented, so the first column does not necessarily correspond to 0 to 1 year olds, and the final
column may be a plus class representing an aggregation of the oldest age classes in the population.
So if 5 age classes are modelled, recruits enter the modelled population at age 3 and the final age
class is a "plus" class, the columns would represent ages the age ranges 3-4, 4-5, 5-6, 6-7 and 7+.

The GYM assumes rigid deterministic relationships between growth, maturation and fishing
selectivity. The length of an individual is a function of age, weight is a function of length, and
maturity and selectivity are functions of length or age.  In Grym, within each year these quantities
are represented as annual matrices as follows:

* `as` is an annual matrix of ages, so that `as[i,j]` is the age of an individual in age class `j`
at the beginning of time step `i`; 
* `ls` is an annual matrix of lengths, so that `ls[i,j]` is the length of an individual in age class `j`
at the beginning of time step `i`; 
* `ws` is an annual matrix of weights, so that `ws[i,j]` is the weight of an individual in age class `j`
at the beginning of time step `i`;
* `gs` is an annual matrix of maturity, so that `gs[i,j]` is the fraction of mature individuals in
  age `j` at the beginning of time step `i`;
* `ss` is an annual matrix of fishing selectivity, so that `ss[i,j]` is the fraction of individuals
  susceptable to fishing in age `j` at the beginning of time step `i`.

The precise form of the functional relationships between these quantities is esentially arbitrary
and may vary from year to year and replicate to replicate, provided that the first and last rows
remain consistent across years.  Only the weights `ws`, maturity `gs` and fishing selectivity `ss`
matrices are required to compute an annual projection, the lengths `ls` and ages `as` are a useful
convenience.

The natural and fishing mortalities are decomposed into the intra-annual components \(m(a,t,y)\) and
\(f(a,t,y)\), and annual scalings \(M_{y}\) and \(F_{y}\) for that year.  For a projection over a
single year, \(M_{y}\) and \(F_{y}\) are just constants, and the intra-annaul components are stored
as annual matrices:

* `ms` is an annual matrix of the intra-annual component of natural mortality \(m(a,t,y)\);
* `fs` is an annual matrix of the intra-annual component of fishing mortality \(f(a,t,y)\).

These matrices are called the *unscaled* natural and fishing mortalities; when scaled by \(M_{y}\)
and \(F_{y}\) they are the *scaled* natural and fishing mortalities:

* `Mms` is an annual matrix of the total natural mortality \(M_{y} m(a,t,y)\);
* `Ffs` is an annual matrix of the total fishing mortality \(F_{y} f(a,t,y)\).

The form of `ms` and `fs` is essentially arbitrary, but in the absence of better information the
unscaled natural mortality is typically assumed constant over a year, while the unscaled fishing
mortality is typically chosen as the product of the fishing selectivity `ss` and some measure of
fishing effort at each time step.  To ensure the annual scalings \(M_{y}\) and \(F_{y}\) are
identifiable, some appropriate normalization must be imposed upon `ms` and `fs`; and this is left to
the discretion of the user.

Computing a projection forward over a year also requires various integrals of the natural and
fishing mortalities.  These quantities are expensive to compute but often do not vary from year to
year,so for efficiency Grym requires the user to provide these rather than recompute them for each
year. The *unscaled integrated* mortalities
\[
\int_{y}^{y+t} m(a,\tau,y) d \tau
\qquad \text{and} \qquad
\int_{y}^{y+t} f(a,\tau,y) d \tau 
\] 
and are provided as annual matrices

* `Ms` is an annual matrix of the unscaled integrated natural mortality;
* `Fs` is an annual matrix of the unscaled integrated fishing mortality,

while the *scaled integrated* mortalities
\[
M_{y} \int_{y}^{y+t} m(a,\tau,y) d \tau
\qquad \text{and} \qquad
F_{y} \int_{y}^{y+t} f(a,\tau,y) d \tau 
\] 
aand are provided as

* `MMs` is an annual matrix of the scaled integrated natural mortality;
* `FFs` is an annual matrix of the scaled integrated fishing mortality.

For some computations only the integration over the entire year is relevant. The final row of an
annual matrix is called a *final vector*, and 

* `Msf` and `Fsf` denote the final vectors of the unscaled integrated mortalities, and
* `MMsf` and `FFsf` denote the final vectors of the scaled integrated mortalities.



A forward projection over a year produces the projected abundance (number of individuals), biomass
and optionally the yield. The projection functions return these as a list with components

* `N` - an annual matrix of abundance
* `B` - an annual matrix of biomass, and optionally
* `Y` - either an annual matrix or final vector of yield.

These matrices are then to produce various annual summaries as required.


## Quadrature
```{r}
library(Grym)
```


Given a set of function values \(f(x_{k})\) sampled at even increments \(x_{k} = x_{1}+(k-1) h\),
the integral \(\int_{x_{1}}^{x_{n}} f(\tau) d\tau\) can be approximated by the composite
[trapezoidal rule](wikipedia.org/wiki/Trapezoidal_rule)
\[
\int_{x_{1}}^{x_{n}} f(\tau) d\tau = \frac{h}{2}f(x_{1}) + h \sum_{k=2}^{n-1} f(x_{k}) + \frac{h}{2} f(x_{n})
\]
The `trapz` function implements the composite trapzoidal rule.  Given a vector `fs` of function
values \(f(x_{k})\), `trapz` returns the trapezoidal approximation to \(\int_{x_{1}}^{x_{n}} f(\tau)
d\tau\). If `fs` is a matrix, then each column is assumed to represent a different integrand
\(f(x)\), and `trapz` returns acts on the columns to return a vector of approximate integrals.
```{r,eval=FALSE}
<<trapz>>
```

The `ctrapz` function is similar except that it returns the sequence of successive approximations \[\left
( \int_{x_{1}}^{x_{1}} f(\tau) d\tau, \int_{x_{1}}^{x_{2}} f(\tau)
d\tau, \ldots, \int_{x_{1}}^{x_{n}} f(\tau) d\tau \right ).
\]  
The result is always the same size as `fs`. 
```{r,eval=FALSE}
<<ctrapz>>
```

With these definitions, if `ms` is a annual matrix of natural mortality, `fs` is a annual matrix of
fishing mortality and `h` is the length of a time step, then annual matrices of integrated mortalities
\[ 
\int_{y}^{y+t} m(a,\tau,y) d \tau \qquad \text{and} \qquad \int_{y}^{y+t} f(a,\tau,y) d \tau
\]
can be computed as
```{r,eval=FALSE}
Ms <- ctrapz(ms,h)
Fs <- ctrapz(ms,h)
```

The the various scaled and final integrated mortalities required for a projection can then be computed as
```{r,eval=FALSE}
Mms <- M*ms
Ffs <- F*fs
MMs <- M*Ms
FFs <- F*Fs
Msf <- Ms[nrow(Ms)]
Fsf <- Fs[nrow(Fs)]
MMsf <- MMs[nrow(MMs)]
FFsf <- FFs[nrow(FFs)]
```



## Annual Projection


When both natural and fishing mortalities are known the computation to project across a single year
is straightforward. 

Given annual matrices `ms` and `fs` of unscaled mortalities, an annual matrix `ws` of weight at age
and a vector `N0` of initial abundances for each age class, then projections of abundance `N`,
biomass `B` and yield `Y` can be calculated as
```{r,eval=FALSE}
## Integrate m and f over the year
h <- 1.0/(nrow(ms)-1)
Ms <- ctrapz(ms,h)
Fs <- ctrapz(fs,h)

## Integrate N and scale by initial values
N <- exp(-M*Ms-F*Fs)
for(j in seq_len(ncol(N))) N[,j] <- N0[j]*N[,j]
    
## Scale by weight at age
B <- ws*N 
  
## Integrate yield
Y <- ctrapz(F*fs*B,h)
```


### Known Fishing Mortality

A minor generalization allows the projection to be scaled to abundance or total biomass estimates
from a survey.  The initial abundances simply scale the integrated profiles over time. If the number
of individuals in each age class are known at some other reference time (for example through a
survey), it suffices to integrate as before but adjust the scaling to reproduce the known abundance
at the reference time.  In some instances only relative cohort abundances are known at some reference
time, but total biomass is known at some (possibly different) reference time and projections should
be scaled to reproduce both the relative abindance and the known total biomass.  In essence this
back-projects the reference abundance or biomass to the start of the year.

The computation of yield is relatively expensive and is not always required, and so the `yield` flag
allows the yield to be computed only for the final time step, all time steps, or not at all

Given

* `ws` - matrix of weights at age
* `MMs` - matrix of scaled integrated natural mortalities
* `FFs` - matrix of scaled integrated fishing mortalities
* `Ffs` - matrix of scaled fishing mortalities 
* `Nref` - vector of reference abundances for each age class
* `nref` - vector of time steps for which the reference abundance is known
* `Bref` - reference biomass 
* `bref` - vector of time steps for which the reference biomass is known
* `yield` - if `yield=1` only calculate yeild for the final time step, if `yield=2`
  calculate yield for all time steps, otherwise yield is not caclulated at all

the `project` function computes annual matrices of projected abundance `N`, biomass `B` and yield `Y`. 
```{r}
<<project>>
```

Given the assumptions of the model, the compuation of `N` and `B` are exact, but the trapezoidal
approximation for `Y` will only be accurate if the total mortality in each time step is small.


### Known Catch

In some cases the annual scaling of fishing mortality \(F_{y}\) is unknown, and must be chosen to
reproduce a given target yield.

The `projectC` function harnesses `project` in conjuction with the univariate root finder `uniroot` to
determine the scaling of fishing mortality \(F_{y}\) that reproduces an observed catch, and then
projects forward for that scaling.  If the target catch cannot be recovered without exceeding `Fmax`,
the projection is performed with `F` capped at `Fmax`.  No warning is issued and it is the
responsibility of the user to check if `F==Fmax`.

Given

* `ws` - matrix of weights at age
* `MMs` - matrix of scaled integrated natural mortalities 
* `Fs` - matrix of unscaled integrated fishing mortalities 
* `fs` - matrix of unscaled fishing mortalities
* `Catch` - target total annual catch
* `Nref` - vector of reference abundances for each age class
* `nref` - vector of time steps for which the reference abundance is known
* `Bref` - reference biomass 
* `bref` - vector of time steps for which the reference biomass is known
* `yield` - if `yield=1` only calculate yeild for the final time step, if `yield=2`
  calculate yield for all time steps, otherwise yield is not caclulated at all
* `Fmax` - the maximum `F` to allow in the search
* `tol` - the precision to which to reproduce the observed catch

the `projectC` function computes matrices of projected abundance `N`, biomass `B`, yield `Y` and
annual scaling of fishing mortality `F` that reproduces the target catch
```{r,eval=FALSE}
<<projectC>>
```


### Age Progression

At the end of an annual projection, the initial abundances for the next projection are formed by
filling the lowest age class with recruits and advancing the final projected cohort abundance by one
age class.  If the final class is a "plus" class, the individuals in the final age class of the
projection are retained, otherwise these individuals are discarded.

Given 

* `N` - matrix of projected abundance
* `R` - number of recruits
* `plus` - is the final age class a "plus" class.

the `advance` function determines the initial abundances for the next projection
```{r,eval=FALSE}
<<advance>>
``` 


### Rescaling

An existing projection for a fixed `F` can be rescaled to match a reference abundance or biomass.
If the natural and fishing mortalities do not vary inter-annually, it may be faster to compute an
initial projection and repeatedly rescale than to continually reproject.

Given

* `pr` - an exsiting projection
* `Nref` - vector of reference abundances for each age class
* `nref` - vector of time steps for which the reference abundance is known
* `Bref` - reference biomass 
* `bref` - vector of time steps for which the reference biomass is known

the `rescaleProjection` rescales the projection to match the prescribed reference abundance or biomass.
```{r,eval=FALSE}
<<rescaleProjection>>
```




## Size and Maturity

Grym require matrices that map age at each time step to weight, maturity or selectivity.  In
principle these mappings are arbitrary and the user is free to specify these as they choose.  For
convenience, Grym implements a small number of common models for translating between age, length,
weight and maturity, using the same parameterizations as used in the original GYM.

The von Bertalanffy growth model is often used to model length at age
```{r,eval=FALSE}
<<vonBertalanffyAL>>
```

The GYM also offers a variant in which growth is restricted to a fraction \([f_{0},f_{1}]\) of each
year
```{r,eval=FALSE}
<<vonBertalanffyRAL>>
```

Length-weight replationships are often modelled as a power law
```{r,eval=FALSE}
<<powerLW>>
```

The GYM uses a piecewise linear "ramp" function to model selectivity and maturity - this is simply the
distribution function of a uniform distribution
```{r,eval=FALSE}
<<rampOgive>>
```





## Initial Age Structure

The initial age structure from which to start a projection can be calculated:

1. by back-projecting abundance from the age structure observed in a survey (as in `project`),
2. deterministically assuming mortality and recruitment do not vary inter-annually, or
3. stochastically by projecting abundance forward assuming random recruitment.

### Deterministic Age Structure

To determine the deterministic equilibrium age structure it is necessary to assume natural mortality
and fishing mortality do not vary inter-annually, but may vary intra-annually and with age.

As \(M_{y}\) and \(F_{y}\) do not vary across seasons, it suffices to compute the survival for each
age class across a single year, and then compute the cumulative survival for each age class.  If
the last age class is a plus class, we extend the single year survivals to allow for the additional
age classes captured by the plus class.  This only constructs a relative age structure, which must
be scaled by the mean recruitment

Given

* `MMsf` - vector of final scaled integrated natural mortalities
* `FFsf` - vector of final scaled integrated fishing mortalities
* `R` - mean number of recruits
* `plus` - the number of additional age classes in the plus class (`plus=0` implies no plus class).

the `ageStructureD` function returns the corresponding vector of equilibrium abundances
```{r,eval=FALSE}
<<ageStructureD>>
```



### Stochastic Age Structure

To stochastically determine an initial age structure it suffices to project forward for at least as
many years as there are age classes with non neglible numbers (including age classes
aggregated into the plus group).

This routine optimizes for when there is no inter-annual variability in the natural and fishing
mortality, in which case the survival of each age class over a single year is constant and can be
precomputed.

Given

* `R` - vector of yearly recruitment numbers
* `Msf` - vector of final unscaled integrated natural mortalities 
* `M` - vector of annual natural mortalities
* `Fsf` - vector of final unscaled integrated fishing mortalities 
* `F` - vector of annual fishing mortalities
* `plus` - whether the final class is a "plus" class

the `ageStructureS` function returns a random initial vector of abundances
```{r,eval=FALSE}
<<ageStructureS>>
```




## Stock Summaries


The spawning stock abundance and biomass are the determined from the projected abundance and biomass
by scaling by the expected fraction mature at age and summing the contribution from each age class
averaged over the spawning period.

Given

* `P` - matrix of projected abundance or biomass
* `gs` - matrix of fraction mature at age
* `period` - the time steps corresponding to the spawning period

the `spawningStock` function returns the mean spawning stock abundance
or biomass
```{r,eval=FALSE}
<<spawningStock>>
```


The stock abundance and biomass that are vulnerable to fishing are the determined from the projected
abundance and biomass by scaling by the selectivity at age and summing the contribution from each
age class averaged over the monitoring period.

Given

* `P` - matrix of projected abundance or biomass
* `ss` - matrix of selectivity at age
* `period` - the time steps corresponding to the monitoring period

the `vulnerableStock` function returns the mean vulnerable stock abundance
or biomass
```{r,eval=FALSE}
<<vulnerableStock>>
```

Within the GYM, the vulnerable stock is calculated by weighting by the within year fishing
effort for the monitoring period. Given

* `fwy` - vector of within year distribution of effort for the year.
* `ss` - matrix of selectivity at age
* `P` - matrix of projected abundance or biomass
* `period` - the time steps corresponding to the monitoring period

the `vulnerableStockGYM` function returns the effort weighted mean vulnerable stock abundance
or biomass
```{r,eval=FALSE}
<<vulnerableStockGYM>>
```




### Deterministic Virgin Spawning Bomass

A deterministic estimate of the virgin spawning biomass is obtained by deterministically computing
the initial age structure and projecting forward to determine the spawning stock biomass.

Given

* `gs` - matrix of fraction mature at age
* `MMsf` - vector of final scaled integrated natural mortalities
* `spawn` - the time steps corresponding to the spawning period
* `R` - the mean numbers of recruits
* `plus` - the number of additional age classes in the plus class (`plus=0` implies no plus class).

the `ageStructureD` function returns the corresponding vector of equilibrium abundances
```{r,eval=FALSE}
<<spawningB0D>>
```


### Stochastic Virgin Spawning Bomass

A stochastic estimate of the virgin spawning biomass is obtained by repeatedly simulating an initial
age structure and projecting forward to simulate a spawning stock biomass.  The median, mean and
standard deviation of the simulated spawning biomasses are returned.

Given

* `R` - matrix or yearly recruitment numbers
* `gs` - matrix of fraction mature at age
* `Ms` - marix of unscaled integrated natural mortalities 
* `M` - vector of annual natural mortalities
* `spawn` - the time steps corresponding to the spawning period
* `plus` - whether the final class is a "plus" class

the `spawningB0S` function returns the median, mean and standard deviation of the simulated virgin
spawning biomasses
```{r,eval=FALSE}
<<spawningB0S>>
```


## Recruitment

The GYM offers a number of options for modelling recruitment including drawing from a log Normal
distribution, bootstrapping from a known time series of recruitments, or the proportional
recruitment model described in @DLMrecruit94.


### Proportional Recruitment (GYM)

These following functions replicate the algorithms for proportional recruitment implemented in the
GYM and described in @DLMrecruit94.  The implementation in the GYM differs slightly from
@DLMrecruit94 in the expressions used for bias correction.

Assume the population recruits to the first age class, and let \(A_{k}\) denote the number of
individuals currently in age class \(k\), and let \(R\) denote the number of individuals in age
class \(r\) as a proportion of all individuals of that age or older
\[
R = \frac{A_{r}}{\sum_{k=r} A_{k}}.
\]

Then given estimates of the mean \(\mu_{R}\) and variance \(\sigma^{2}_{R}\) of \(R\) derived from
independent surveys, the proportional recruitment model generates random number of recruits that
would reproduce the observed values of the mean \(\mu_{R}\) and variance \(\sigma^{2}_{R}\) of the
proportion \(R\).

Given 

* `mnR` - an estimate of the mean of \(R\) from independent surveys
* `vrR` - an estimate of the variance of \(R\) from independent surveys
* `Msf` - vector of final unscaled integrated natural mortalities
* `r` - the reference age class
* `plus` - the number of additional age classes in the plus class (`plus=0` implies no plus class).
* `Mbrak` - the values of natural mortality to assess when bracketing
  a root for the nonlinear solver
* `tol` - the tolerance for nonlinear solver 

the `prRecruitParsGYM` function generates the parameters needed to draw random numbers of recruits.
```{r,eval=FALSE}
<<prRecruitParsGYM>>
```

Given

* `n` - the number of recruitment events
* `ps` - a list of parameters returned by `prRecruitParGYM`
* `mnA` - the mean number of recruits

the `prRecruitsGYM` function generates the corresponding random numbers of recruits.  Note that the bias 
correction can lead to negative deviates and so a rejection scheme is used to draw only positive deviates, 
but this results in bias.
```{r,eval=FALSE}
<<prRecruitsGYM>>
```


### Proportional Recruits

Grym offers a formulation of proportional recruitment model that differs from that described in
@DLMrecruit94.

Assume the population recruits to the first age class, and let \(A_{k}\) denote the number of
individuals currently in age class \(k\), \(a_{k}\) the number of individuals originally recruited
to that cohort, and \(S_{k}\) the survival from recruitment to the current time so that for each age
class \(A_{k} = a_{k} S_{k}\), and \(A_{1}=a_{1}\) with \(S_{1}=1\).

As in @DLMrecruit94, let \(R\) denote the number of individuals in age class \(r\) as a proportion of the
population of individuals of the same age or older
\[
R = \frac{A_{r}}{\sum_{k=r} A_{k}} = \frac{a_{r} S_{r}}{\sum_{k=r} a_{k} S_{k}}=\frac{a_{r}}{a_{r} +S_{r}^{-1}\sum_{k=r+1} a_{k} S_{k}} 
\]
and suppose estimates of the mean \(\mu_{R}\) and variance \(\sigma^{2}_{R}\) of \(R\) can be
derived from independent surveys.

The model simulates numbers of recruits \(a_{1}\) as a stochastic fraction \(Q\) of the expected
number of individuals above recruitment age
\[
a_{1} = Q \operatorname{E}\left ( \sum_{k=2} A_{k} \right ),
\]
where the mean \(\mu_{Q}\) and variance \(\sigma^{2}_{Q}\) of \(Q\) are chosen to reproduce the
observed \(\mu_{R}\) and \(\sigma^{2}_{R}\).  In this model \(Q\) can be interpreted as the odds of recruits.

Assuming the numbers of recruits each year are independently and identically distributed with mean
\(\mu_{a}\),
\[
a_{1} = Q \operatorname{E}\left ( \sum_{k=2} a_{k} S_{k} \right ) = Q \mu_{a} \sum_{k=2} S_{k}.
\]

Taking the expected value of both sides of this relation 
\[
\mu_{a}  = \mu_{Q} \mu_{a} \sum_{k=2} S_{k}
\]
shows that the natural mortality \(M\) must be chosen to give survivals \(S_{k}\) such that 
\[
\mu_{Q} = \left ( \sum_{k=2} S_{k}\right )^{-1}.
\]  

Define the sums
\[
\begin{align}
  s_{0}&=\sum_{k=2} S_{k}\\
  s_{1}&=S_{r}^{-1}\sum_{k=r+1} S_{k}\\
  s_{2}&=S_{r}^{-2}\sum_{k=r+1} S_{k}^{2}.
\end{align}         
\]
Then approximately 
\[
\begin{align}
\mu_{R} 
&=\frac{\operatorname{E}(a_{r}S_{r})}{\operatorname{E}\left (\sum_{k=r} a_{k} S_{k}\right )} 
-\frac{\operatorname{Cov}(a_{r}S_{r},\sum_{k=r} a_{k} S_{k})}{\operatorname{E}\left (\sum_{k=r} a_{k} S_{k}\right )^{2}}+
\frac{\operatorname{E}(a_{r}S_{r})\operatorname{Var}\left ( \sum_{k=r} a_{k} S_{k}\right )}{\operatorname{E}\left (\sum_{k=r} a_{k} S_{k}\right )^{3}}
\\
&=\frac{\mu_{a}S_{r}}{\mu_{a}\sum_{k=r} S_{k}} 
-\frac{\sigma_{a}^{2}S_{r}^{2}}{\left (\mu_{a}\sum_{k=r} S_{k}\right )^{2}}+
\frac{\mu_{a} \sigma_{a}^{2}S_{r}\sum_{k=r} S_{k}^{2}}{\left (\mu_{a}\sum_{k=r} S_{k}\right )^{3}}
\\
&=\frac{\mu_{a}}{\mu_{a}(1+s_{1})} 
-\frac{\sigma_{a}^{2}}{\mu_{a}^{2}(1+s_{1})^{2}}+
\frac{\mu_{a} \sigma_{a}^{2}(1+s_{2})}{\mu_{a}^{3}(1+s_{1})^{3}}
\\
&=\frac{1}{(1+s_{1})}+
\frac{\sigma_{a}^{2}(s_{2}-s_{1})}{\mu_{a}^{2}(1+s_{1})^{3}}
\end{align}
\]
and 
\[
\begin{align}
\sigma_{R}^{2}
&=\frac{\operatorname{E}(a_{r}S_{r})^{2}}{\operatorname{E}\left (\sum_{k=r} a_{k} S_{k}\right )^{2}} 
\left [
\frac{\operatorname{Var}(a_{r}S_{r})}{\operatorname{E}(a_{r}S_{r})^{2}}
-2\frac{\operatorname{Cov}(a_{r}S_{r},\sum_{k=r} a_{k} S_{k})}{\operatorname{E}(a_{r}S_{r})\operatorname{E}\left (\sum_{k=r} a_{k} S_{k}\right )}+
\frac{\operatorname{Var}\left ( \sum_{k=r} a_{k} S_{k}\right )}{\operatorname{E}\left (\sum_{k=r} a_{k} S_{k}\right )^{2}}
\right ]\\
&=\frac{\mu_{a}^{2}}{\mu_{a}^{2}(1+s_{1})^{2}} 
\left [
\frac{\sigma_{a}^{2}}{\mu_{a}^{2}}
-\frac{2\sigma_{a}^{2}}{\mu_{a}^{2}(1+s_{1})}+
\frac{\sigma_{a}^{2}(1+s_{2})}{\mu_{a}^{2}(1+s_{1})^{2}}
\right ]\\
&=\frac{\sigma_{a}^{2}(s_{1}^{2}+s_{2})}{\mu_{a}^{2}(1+s_{1})^{4}},
\end{align}
\]
from which it is deduced
\[
\sigma_{a}^{2}=\frac{\mu_{a}^{2}\sigma_{R}^{2}(1+s_{1})^{4}}{(s_{1}^{2}+s_{2})}.
\]
and hence
\[
\mu_{R} =\frac{1}{(1+s_{1})}+
\frac{(1+s_{1})(s_{2}-s_{1})\sigma_{R}^{2}}{s_{1}^{2}+s_{2}}.
\]

As \(s_{1}\) and \(s_{2}\) are functions of natural mortality \(M\), this expression can be solved
for \(M\) and hence \(s_{1}\) and \(s_{2}\), and hence
\[
\begin{align}
\mu_{Q} &= s_{0}^{-1}\\
\sigma_{Q}^{2} &= \frac{(1+s_{1})^{4} \sigma_{R}^{2}}{s_{0}^{2}(s_{1}^{2}+s_{2})}.
\end{align}
\]

These expressions determine the mean and variance of the stochastic fraction \(Q\) required to
reproduce the \(\mu_{R}\) and \(\sigma^{2}_{R}\) observed in surveys.  The fraction \(Q\) may have
any distribution with mean \(\mu_{Q}\) and variance \(\sigma_{Q}^{2}\) that has the positive real
line as support.

The equation above is solved for natural mortality using a standard bisection procedure after first
bracketing the root by evaluating the equation at a set of mortalities provided by the user.


Given 

* `mnR` - an estimate of the mean of \(R\) from independent surveys
* `vrR` - an estimate of the variance of \(R\) from independent surveys
* `Msf` - vector of final unscaled integrated natural mortalities
* `r` - the reference age class
* `plus` - the number of additional age classes in the plus class (`plus=0` implies no plus class).
* `Mbrak` - the values of natural mortality to assess when bracketing
  a root for the nonlinear solver
* `tol` - the tolerance for nonlinear solver 

the `prRecruitPars0` function generates the mean and variance of \(Q\), and the sum \(s_{0}\)
required by the proportional recruitment model, and is used to define specific families of random
recruitments below
```{r,eval=FALSE}
<<prRecruitPars0>>
```


#### Inverse Beta

The model implemented in the GYM assumes the proportion of recruits is Beta distributed, and the
natural analog in the model considered here is to assume the odds of recruits \(Q\) has an inverse
Beta distribution.

If the proportion \(R\) is Beta distributed with shape parameters \(a\) and \(b\), then the
corresponding odds \(Q = \frac{R}{1-R}\) will be inverse Beta distributed with the same parameters
\[
Q \sim \operatorname{Beta}^{\prime}(a,b),
\]
with mean \(\mu_{Q}=\operatorname{E}(Q)\) and variance \(\sigma_{Q}^{2}=\operatorname{Var}(Q)\) 
\[
\begin{align}
\mu_{Q} &= \frac{a}{b-1}\\
\sigma_{Q}^{2} &= \frac{a (a+b-1)}{(b-2)(b-1)^{2}}
\end{align}
\]
The shape parameters the yield a given mean and variance are
\[
\begin{align}
a &= \frac{\mu_{Q}(\mu_{Q}(1+\mu_{Q})+\sigma_{Q}^{2})}{\sigma_{Q}^{2}}\\
b &= \frac{\mu_{Q}(1+\mu_{Q})+2\sigma_{Q}^{2}}{\sigma_{Q}^{2}}.
\end{align}
\]

The `prRecruitParsIB` variant generates the parameters for the proportional recruitment model
assuming the fraction of recruits has an inverse Beta distribution
```{r,eval=FALSE}
<<prRecruitParsIB>>
```
and `prRecruitsIB` generates the corresponding random numbers of recruits
```{r,eval=FALSE}
<<prRecruitsIB>>
```

The `prRecruitParsDIB` variant generates the parameters for the proportional recruitment model
assuming the fraction of recruits has a "delta" inverse Beta distribution in which a fraction `p` of
events yield zero recruits
```{r,eval=FALSE}
<<prRecruitParsDIB>>
```
and `prRecruitsDIB` generates the corresponding random numbers of recruits
```{r,eval=FALSE}
<<prRecruitsDIB>>
```

#### Gamma

If the fraction \(Q\) is assumed to be Gamma distributed with shape parameters \(a\) and \(b\)
\[
Q \sim \operatorname{Gamma}(a,b),
\]
then
\[
\begin{align}
a &= \frac{\mu_{Q}^{2}}{\sigma_{Q}^{2}}\\
b &= \frac{\mu_{Q}}{\sigma_{Q}^{2}}
\end{align}
\]

The `prRecruitParsG` variant generates the parameters for the proportional recruitment model
assuming the fraction of recruits is Gamma distributed
```{r,eval=FALSE}
<<prRecruitParsG>>
```
and `prRecruitsG` generates the corresponding random numbers of recruits
```{r,eval=FALSE}
<<prRecruitsG>>
```

The `prRecruitParsDG` variant generates the parameters for the proportional recruitment model
assuming the fraction of recruits is "delta" Gamma distributed in which a fraction `p` of events
yield zero recruits
```{r,eval=FALSE}
<<prRecruitParsDG>>
```
and `prRecruitsDG` generates the corresponding random numbers of recruits
```{r,eval=FALSE}
<<prRecruitsDG>>
```


#### Log Normal

If the fraction \(Q\) is assumed to have a log Normal distribution with parameters \(\mu\) and \(\sigma^{2}\)
\[
Q \sim \operatorname{LogNormal}(\mu,\sigma^2),
\]
then
\[
\begin{align}
\mu &= \log \frac{\mu_{Q}^{2}}{\mu_{Q}^{2} + \sigma_{Q}^{2}}\\
\sigma^{2} &= \log \frac{\mu_{Q}^{2} + \sigma_{Q}^{2}}{\mu_{Q}^{2}}\\
\end{align}
\]
The `prRecruitParsLN` variant generates the parameters for the proportional recruitment model
assuming the fraction of recruits is log Normal
```{r,eval=FALSE}
<<prRecruitParsLN>>
```
and `prRecruitsLN` generates the corresponding random numbers of recruits
```{r,eval=FALSE}
<<prRecruitsLN>>
```

The `prRecruitParsDLN` variant generates the parameters for the proportional recruitment model
assuming the fraction of recruits is "delta" log Normal in which a fraction `p` of events yield zero
recruits
```{r,eval=FALSE}
<<prRecruitParsDLN>>
```
and `prRecruitsDLN` generates the corresponding random numbers of recruits
```{r,eval=FALSE}
<<prRecruitsDLN>>
```


### Variability in Survey Estimates

To account for uncertainly in the survey based estimates of the mean and variance of \(R\),
@DLMrecruit94 suggests simulating new values for mean \(R\) from a Normal distribution and new
values for the variance of \(R\) from a Chi-squared distribution.  But \(R\) is a proportion and so
has bounded variance, so simulating from a Chi-squared distribution is extremely inadvisable. It is
almost certainly this procedure that is cause of the failure reported in @Kinzey13.

#### GYM 

The following function implements the procedure used in the GYM to resample the mean and variance of
\(R\).  Note that the prescription in @DLMrecruit94 erroneously uses the standard deviation not the
standard error of the mean when resampling for \(R\).


This function should not be used as it generates variances that are impossibly large
```{r,eval=FALSE}
<<resampleRGYM>>
```

#### Bootstrap

As an alternative, Grym uses parametric bootstrap to simulate new values for the mean and variance
of \(R\) that are consistent with the observed values. If the original mean and variance were
estimated from \(n\) independent surveys, random recruits based on the observed mean and variance
are used to generate \(n\) new age structures from which \(R\) and hence the mean and variance of
\(R\) are estimated.  This procedure is guaranteed to produce realistic variances

Given 

* `prRec` - a function for generating random number of recruits from a proportional recruitment
  model
* `ps`  - a list of model parameters
* `n` - the number of independent surveys used in the estimation of the mean and variance of R
* `Msf` - vector of final unscaled integrated natural mortalities
* `r` - the reference age class
* `plus` - the number of additional age classes in the plus class (`plus=0` implies no plus class).

the `prBootstrap` function generates new values for the mean and variance of \(R\).
```{r,eval=FALSE}
<<prBootstrap>>
```


## Survival to survey period

The `surveySurvival` function determines the total surival from recruitment to a nominated survey
period.  This can be used to backproject age specific abundance survey data to estimate annual
recruitments.

When there is inter-annual variability in natural or fishing mortality, the annual mortality
scalings (`M` and/or `F`) are specified as vectors, and it is assumed that survey years are labelled
so that `yr==1` corresponds to the year of the first elemnt of `M` or `F`.  Survival cannot be
computed for cohorts recruited before year 1.

When there is no inter-annual variability in natural or fishing mortality and the vectors `M` and
`F` are both of length one, the survey year is essential irrelevant and is ignored.

Given

* `Ms` - matrix of unscaled integrated natural mortalities 
* `M` - vector of annual natural mortalities
* `Fs` - matrix of unscaled integrated fishing mortalities 
* `F` - vector of annual fishing mortalities
* `yr` - vector of the survey year
* `cls` -  vector of age classes surveyed
* `s1`, `s2` -  vector of the start and end time step of the survey

the `surveySurvival` function generates the total survival from time
of recruitment to the first age class to the survey period.
```{r,eval=FALSE}
<<surveySurvival>>
```




## TODO

Some basic functionality still needs to be implemented, including

* Parametric bootstrap from a vector of recruits 


## Issues


#### Caching

The code has been optimized to make the very low level projection function as cheap to compute as
possible.  In large part this has been done by requiring the user to precompute various matrices of
natural and fishing mortality that are likely to remain constant across projections.

But the cost of this strategy is that it complicates the argument lists of the functions, and
similar functions can expect sublty different arguments, which is likely to lead to programming
errors. It may be better to unify the argument lists across functions a little more at the cost of
recomputing some expressions that are not too expensive to compute.


#### Normalization

The GYM standardises the natural and fishing mortalities according to specific rules, but it is not
clear that these rules are consistent if the fishing season is allowed to change inter-annually.  In
Grym, we have not formalized the standardizaiton in any way, we have left it up to the programmer
to standardize as they see fit.

#### Averages 


Arguably, the `mean` in `project` that computes the average over the reference interval should be an
integral over the interval computed with `trapz` rather than a simple mean.  Similar arguments apply
to the calculation of stock averages such as spawning biomass and vulnerable biomass.

This would break consistency with the GYM, but be more internally consistent.


#### Runge Kutta

In the GYM projection is based on integrating a set of ODE's with a Runge-Kutta procedure, but the
implmentation seems oddly inaccurate.  For example - when calculating median SB0, the GYM projects 
forward with unit abundance in each age class with no fishing mortality. Even though mortalities and 
initial abundances are identical, inspection with a single step debugger shows the Runge-Kutta produces
projected abundances that differ cross age groups in the fifth or sixth significant figure.  A Runge-Kutta
procedure should be more accurate than this.


#### Plus Class

In some functions Grym treats age as potentially unlimited so that the plus class contains
potentially infinitely many age classes.  But in others Grym treats the plus class as containing
only finitely many ages and the user must specify how many "additional" age classes reside in the
plus class essentially placing an upper limit on the age of an individual. The two sets of functions 
can be distinguished by whether the `plus` argument is bolean (infinite age) or integer (finite age).

In one sense this is not really a problem in that the number of additional age classes can be set
arbitrarily large (at the cost of computational effort), but it would be better if there were more
consistency.

There are three main cases to consider:

1. In repeated yearly projections, any individual that enters the plus class "loses" its age, so in
   principle an individual in the plus class can be infinitely old.  In practice this does not
   happen, the upper age will always be limited by the number of previous years of recruitment simulated.

2. If there is no inter-annual variability in mortalities, then it is possible to analytically
   determine quantities such as initial age structure and long term survival for arbitrary age
   limits ages in the plus group.  For example `ageStructureD` will compute an initial age structure
   allowing an arbitrary limit on the number of additional age classes in the plus group.

3. But in the presence of inter-annual variability, it is not possible to determine simple analytic
   expressions for the age structure and an initial age structure must be computed by simulation.
   In this case maximum age in the plus class is determined by how many years of recruitment the
   simulation is based on.  



#### Summary Functions

The summary functions Grym provides need to be thought through carefully to provide a sensible balance
between utility and efficiency.

* should `initial` and `final` have an option to sum across age classes?

* should `meanStock`, `spawningStock`, `exploitableStock` and `vulnerableStock` have an option to
  not sum across age classes but produce age class specific results?



#### Proportional Recruitment

The proportional recruitment model used within the GYM is in itself workable, although Grym offers
more general alternatives with better bias correction.

But the process for resampling the mena and variance of \(R\) proposed in @DLMrecruit94 is not
reasonable and leads to impossible variances.  Grym proposes a parametric bootstrap alternative,
but as with all bootstrap approaches it is like to underestimate variability, and there may be
better alternatives.
  
#### Memory Management

Memory management in the current implementation of R is oddly temperamental, and so some care needs
to be taken when writing projection code.

Commonly we wish to project forward over several years and collate annual summaries.  But if we
preallocate a dataframe to store the summaries, then repeatedly project forward writing annual
summary to the appropriate row of the dataframe, R performs an unnecessary copy fo teh data frame
each time a row is written.  If instead we allocate vectors for each separate summary quantity, and
then bind these together as a dataframe when the projection is complete, the level of copying is
vastly reduced.  There is a helpful disccusion on this [blog](https://www.brodieg.com/2019/02/18/an-unofficial-reference-for-internal-inspect/)

As a general rule, it is more efficient to 

* store results to vectors that are then bound together to form a dataframe rather than allocate
  dataframes and write inidividual results to that dataframe, and

* create many small dataframes that summarize a small number of projections, and bind these together
  to create the final result.

The upshot is that the most efficient code is not always the cleanest/most obvious.





## References
